//
//     Generated by classdump-c 4.2.0 (64 bit).
//
//  Copyright (C) 1997-2019 Steve Nygard. Updated in 2022 by Kevin Bradley.
//

#pragma mark Blocks

typedef void (^CDUnknownBlockType)(void); // return type and parameters are unknown

#pragma mark Named Structures

struct CGAffineTransform {
    double a;
    double b;
    double c;
    double d;
    double tx;
    double ty;
};

struct CGSize {
    double _field1;
    double _field2;
};

struct EncoderConfig {
    int _field1;
    int _field2;
    int _field3;
    int _field4;
    double _field5;
    _Bool _field6;
    _Bool _field7;
    _Bool _field8;
    _Bool _field9;
    _Bool _field10;
    int _field11;
};

struct HEVCLosslessEncoder {
    id _field1;
    int _field2;
    int _field3;
    double _field4;
    struct OpaqueVTCompressionSession *_field5;
    struct EncoderConfig _field6;
    CDStruct_1b6d18a9 _field7;
    unsigned int _field8;
    unsigned int _field9;
    unsigned int _field10;
    _Bool _field11;
    _Bool _field12;
};

struct OpaqueVTCompressionSession;

struct StreamRecordingData {
    struct opaqueCMFormatDescription *_field1;
    _Bool _field2;
    id _field3;
    id _field4;
    id _field5;
    id _field6;
    id _field7;
    id _field8;
    unsigned long long _field9;
    id _field10;
    id _field11;
    struct __CVPixelBufferPool *_field12;
    id _field13;
    id _field14;
    id _field15;
    CDStruct_1b6d18a9 _field16;
    unsigned long long _field17;
    id _field18;
    long long _field19;
};

struct __tree_end_node<std::__tree_node_base<void *>*> {
    void *__left_;
};

struct basic_string<char, std::char_traits<char>, std::allocator<char>> {
    struct __compressed_pair<std::basic_string<char>::__rep, std::allocator<char>> {
        struct __rep {
            union {
                struct __long {
                    unsigned long long _field1;
                    unsigned long long _field2;
                    char *_field3;
                } _field1;
                struct __short {
                    union {
                        unsigned char _field1;
                        char _field2;
                    } _field1;
                    char _field2[23];
                } _field2;
                struct __raw {
                    unsigned long long _field1[3];
                } _field3;
            } _field1;
        } _field1;
    } _field1;
};

struct map<std::string, (anonymous namespace)::MetadataRecordingData, std::less<std::string>, std::allocator<std::pair<const std::string, (anonymous namespace)::MetadataRecordingData>>> {
    struct __tree<std::__value_type<std::string, (anonymous namespace)::MetadataRecordingData>, std::__map_value_compare<std::string, std::__value_type<std::string, (anonymous namespace)::MetadataRecordingData>, std::less<std::string>, true>, std::allocator<std::__value_type<std::string, (anonymous namespace)::MetadataRecordingData>>> {
        void *__begin_node_;
        struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *>*>, std::allocator<std::__tree_node<std::__value_type<std::string, (anonymous namespace)::MetadataRecordingData>, void *>>> {
            struct __tree_end_node<std::__tree_node_base<void *>*> __value_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__map_value_compare<std::string, std::__value_type<std::string, (anonymous namespace)::MetadataRecordingData>, std::less<std::string>, true>> {
            unsigned long long __value_;
        } __pair3_;
    } __tree_;
};

struct map<std::string, (anonymous namespace)::StreamRecordingData, std::less<std::string>, std::allocator<std::pair<const std::string, (anonymous namespace)::StreamRecordingData>>> {
    struct __tree<std::__value_type<std::string, (anonymous namespace)::StreamRecordingData>, std::__map_value_compare<std::string, std::__value_type<std::string, (anonymous namespace)::StreamRecordingData>, std::less<std::string>, true>, std::allocator<std::__value_type<std::string, (anonymous namespace)::StreamRecordingData>>> {
        void *__begin_node_;
        struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *>*>, std::allocator<std::__tree_node<std::__value_type<std::string, (anonymous namespace)::StreamRecordingData>, void *>>> {
            struct __tree_end_node<std::__tree_node_base<void *>*> __value_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__map_value_compare<std::string, std::__value_type<std::string, (anonymous namespace)::StreamRecordingData>, std::less<std::string>, true>> {
            unsigned long long __value_;
        } __pair3_;
    } __tree_;
};

struct map<std::string, CMTime, std::less<std::string>, std::allocator<std::pair<const std::string, CMTime>>> {
    struct __tree<std::__value_type<std::string, CMTime>, std::__map_value_compare<std::string, std::__value_type<std::string, CMTime>, std::less<std::string>, true>, std::allocator<std::__value_type<std::string, CMTime>>> {
        void *__begin_node_;
        struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *>*>, std::allocator<std::__tree_node<std::__value_type<std::string, CMTime>, void *>>> {
            struct __tree_end_node<std::__tree_node_base<void *>*> __value_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__map_value_compare<std::string, std::__value_type<std::string, CMTime>, std::less<std::string>, true>> {
            unsigned long long __value_;
        } __pair3_;
    } __tree_;
};

struct map<std::string, std::map<std::string, (anonymous namespace)::MetadataRecordingData>, std::less<std::string>, std::allocator<std::pair<const std::string, std::map<std::string, (anonymous namespace)::MetadataRecordingData>>>> {
    struct __tree<std::__value_type<std::string, std::map<std::string, (anonymous namespace)::MetadataRecordingData>>, std::__map_value_compare<std::string, std::__value_type<std::string, std::map<std::string, (anonymous namespace)::MetadataRecordingData>>, std::less<std::string>, true>, std::allocator<std::__value_type<std::string, std::map<std::string, (anonymous namespace)::MetadataRecordingData>>>> {
        void *__begin_node_;
        struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *>*>, std::allocator<std::__tree_node<std::__value_type<std::string, std::map<std::string, (anonymous namespace)::MetadataRecordingData>>, void *>>> {
            struct __tree_end_node<std::__tree_node_base<void *>*> __value_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__map_value_compare<std::string, std::__value_type<std::string, std::map<std::string, (anonymous namespace)::MetadataRecordingData>>, std::less<std::string>, true>> {
            unsigned long long __value_;
        } __pair3_;
    } __tree_;
};

struct opaqueCMFormatDescription;

struct vector<std::string, std::allocator<std::string>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<std::string *, std::allocator<std::string>> {
        void *__value_;
    } __end_cap_;
};

#pragma mark Typedef'd Structures

typedef struct {
    int _field1;
    int _field2;
} CDStruct_1ef3fb1f;

typedef struct {
    long long value;
    int timescale;
    unsigned int flags;
    long long epoch;
} CDStruct_1b6d18a9;

typedef struct {
    CDStruct_1b6d18a9 _field1;
    CDStruct_1b6d18a9 _field2;
} CDStruct_5c5366e1;

// Template types
typedef struct basic_string<char, std::char_traits<char>, std::allocator<char>> {
    struct __compressed_pair<std::basic_string<char>::__rep, std::allocator<char>> {
        struct __rep {
            union {
                struct __long {
                    unsigned long long _field1;
                    unsigned long long _field2;
                    char *_field3;
                } _field1;
                struct __short {
                    union {
                        unsigned char _field1;
                        char _field2;
                    } _field1;
                    char _field2[23];
                } _field2;
                struct __raw {
                    unsigned long long _field1[3];
                } _field3;
            } _field1;
        } _field1;
    } _field1;
} basic_string_5886a005;

