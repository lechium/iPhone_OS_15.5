//
//     Generated by classdump-c 4.2.0 (64 bit).
//
//  Copyright (C) 1997-2019 Steve Nygard. Updated in 2022 by Kevin Bradley.
//

#pragma mark Named Structures

struct CGPoint {
    double x;
    double y;
};

struct CGRect {
    struct CGPoint origin;
    struct CGSize size;
};

struct CGSize {
    double width;
    double height;
};

struct CinematicTracker;

struct EspressoConfig {
    struct vector<std::string, std::allocator<std::string>> _field1;
    struct optional<espresso_engine_t> _field2;
    int _field3;
    int _field4;
    int _field5;
    struct optional<espresso_plan_priority_t> _field6;
    struct optional<void *> _field7;
    struct unordered_map<std::string, espresso_simple_image_preprocessing_params_t, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, espresso_simple_image_preprocessing_params_t>>> _field8;
    basic_string_5886a005 _field9;
};

struct EspressoNet;

struct EspressoTensor {
    CDUnknownFunctionPointerType *_vptr$Tensor;
    int type_;
    struct TensorShape shape_;
    struct shared_ptr<ik::TensorStorage> storage_;
};

struct Frame;

struct HungarianMatcher;

struct Observation;

struct PixelBufferTensor {
    CDUnknownFunctionPointerType *_vptr$Tensor;
    int type_;
    struct TensorShape shape_;
    struct shared_ptr<ik::TensorStorage> storage_;
};

struct Rect<double> {
    double _field1;
    double _field2;
    double _field3;
    double _field4;
};

struct TensorShape {
    struct vector<unsigned long, std::allocator<unsigned long>> sizes_;
};

struct TensorStorage;

struct Track;

struct __shared_weak_count;

struct basic_string<char, std::char_traits<char>, std::allocator<char>> {
    struct __compressed_pair<std::basic_string<char>::__rep, std::allocator<char>> {
        struct __rep {
            union {
                struct __long {
                    unsigned long long _field1;
                    unsigned long long _field2;
                    char *_field3;
                } _field1;
                struct __short {
                    union {
                        unsigned char _field1;
                        char _field2;
                    } _field1;
                    char _field2[23];
                } _field2;
                struct __raw {
                    unsigned long long _field1[3];
                } _field3;
            } _field1;
        } _field1;
    } _field1;
};

struct optional<espresso_engine_t> {
    CDUnion_0506adf3 _field1;
    _Bool _field2;
};

struct optional<espresso_plan_priority_t> {
    CDUnion_0506adf3 _field1;
    _Bool _field2;
};

struct optional<void *> {
    union {
        char _field1;
        void *_field2;
    } _field1;
    _Bool _field2;
};

struct shared_ptr<__CVBuffer> {
    struct __CVBuffer *__ptr_;
    struct __shared_weak_count *__cntrl_;
};

struct shared_ptr<ft::CinematicTracker> {
    struct CinematicTracker *__ptr_;
    struct __shared_weak_count *__cntrl_;
};

struct shared_ptr<ft::Frame> {
    struct Frame *__ptr_;
    struct __shared_weak_count *__cntrl_;
};

struct shared_ptr<ft::Track> {
    struct Track *_field1;
    struct __shared_weak_count *_field2;
};

struct shared_ptr<ik::TensorStorage> {
    struct TensorStorage *__ptr_;
    struct __shared_weak_count *__cntrl_;
};

struct unique_ptr<ft::HungarianMatcher, std::default_delete<ft::HungarianMatcher>> {
    struct __compressed_pair<ft::HungarianMatcher *, std::default_delete<ft::HungarianMatcher>> {
        struct HungarianMatcher *__value_;
    } __ptr_;
};

struct unique_ptr<ik::EspressoNet, std::default_delete<ik::EspressoNet>> {
    struct __compressed_pair<ik::EspressoNet *, std::default_delete<ik::EspressoNet>> {
        struct EspressoNet *__value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*>*>>> {
        void **_field1;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*>*>> {
                unsigned long long _field1;
            } _field1;
        } _field2;
    } _field1;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unordered_map<std::string, espresso_simple_image_preprocessing_params_t, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, espresso_simple_image_preprocessing_params_t>>> {
    struct __hash_table<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, std::hash<std::string>, std::equal_to<std::string>, true>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, std::equal_to<std::string>, std::hash<std::string>, true>, std::allocator<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*>*>>> _field1;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, void *>*> {
                void *_field1;
            } _field1;
        } _field2;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, std::hash<std::string>, std::equal_to<std::string>, true>> {
            unsigned long long _field1;
        } _field3;
        struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, espresso_simple_image_preprocessing_params_t>, std::equal_to<std::string>, std::hash<std::string>, true>> {
            float _field1;
        } _field4;
    } _field1;
};

struct unordered_map<std::string, ik::Tensor, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, ik::Tensor>>> {
    struct __hash_table<std::__hash_value_type<std::string, ik::Tensor>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, ik::Tensor>, std::hash<std::string>, std::equal_to<std::string>, true>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, ik::Tensor>, std::equal_to<std::string>, std::hash<std::string>, true>, std::allocator<std::__hash_value_type<std::string, ik::Tensor>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, ik::Tensor>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, ik::Tensor>, std::hash<std::string>, std::equal_to<std::string>, true>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, ik::Tensor>, std::equal_to<std::string>, std::hash<std::string>, true>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct vector<ft::Observation, std::allocator<ft::Observation>> {
    struct Observation *_field1;
    struct Observation *_field2;
    struct __compressed_pair<ft::Observation *, std::allocator<ft::Observation>> {
        struct Observation *_field1;
    } _field3;
};

struct vector<std::string, std::allocator<std::string>> {
    void *_field1;
    void *_field2;
    struct __compressed_pair<std::string *, std::allocator<std::string>> {
        void *_field1;
    } _field3;
};

struct vector<unsigned long, std::allocator<unsigned long>> {
    unsigned long long *__begin_;
    unsigned long long *__end_;
    struct __compressed_pair<unsigned long *, std::allocator<unsigned long>> {
        unsigned long long *__value_;
    } __end_cap_;
};

#pragma mark Typedef'd Structures

typedef struct {
    void *data;
    void *reserved;
    unsigned long long dim[4];
    unsigned long long stride[4];
    unsigned long long width;
    unsigned long long height;
    unsigned long long channels;
    unsigned long long batch_number;
    unsigned long long sequence_length;
    unsigned long long stride_width;
    unsigned long long stride_height;
    unsigned long long stride_channels;
    unsigned long long stride_batch_number;
    unsigned long long stride_sequence_length;
    int storage_type;
} CDStruct_0a65202a;

typedef struct {
    long long value;
    int timescale;
    unsigned int flags;
    long long epoch;
} CDStruct_1b6d18a9;

typedef struct {
    struct CGRect _field1;
    double _field2;
} CDStruct_1586d5e9;

// Template types
typedef struct Rect<double> {
    double _field1;
    double _field2;
    double _field3;
    double _field4;
} Rect_afd4f3fa;

typedef struct basic_string<char, std::char_traits<char>, std::allocator<char>> {
    struct __compressed_pair<std::basic_string<char>::__rep, std::allocator<char>> {
        struct __rep {
            union {
                struct __long {
                    unsigned long long _field1;
                    unsigned long long _field2;
                    char *_field3;
                } _field1;
                struct __short {
                    union {
                        unsigned char _field1;
                        char _field2;
                    } _field1;
                    char _field2[23];
                } _field2;
                struct __raw {
                    unsigned long long _field1[3];
                } _field3;
            } _field1;
        } _field1;
    } _field1;
} basic_string_5886a005;

typedef struct shared_ptr<ft::CinematicTracker> {
    struct CinematicTracker *__ptr_;
    struct __shared_weak_count *__cntrl_;
} shared_ptr_0abad622;

typedef struct shared_ptr<ft::Frame> {
    struct Frame *__ptr_;
    struct __shared_weak_count *__cntrl_;
} shared_ptr_a4dcdb7c;

typedef struct shared_ptr<ft::Track> {
    struct Track *_field1;
    struct __shared_weak_count *_field2;
} shared_ptr_a265d236;

typedef struct vector<ft::Observation, std::allocator<ft::Observation>> {
    struct Observation *_field1;
    struct Observation *_field2;
    struct __compressed_pair<ft::Observation *, std::allocator<ft::Observation>> {
        struct Observation *_field1;
    } _field3;
} vector_6c010fa3;

#pragma mark Typedef'd Unions

typedef union {
    char _field1;
    int _field2;
} CDUnion_0506adf3;

